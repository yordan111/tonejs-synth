<!DOCTYPE html>
<html>
<head>
    <title>Tone.js Synth with ADSR, Unison & Effects</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 700px;
            margin: 50px auto;
            padding: 20px;
            background: #1a1a1a;
            color: #fff;
        }
        .synth-container {
            background: #2d2d2d;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #4fc3f7;
        }
        .control-group {
            margin-bottom: 25px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }
        select, input[type="range"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            background: #3d3d3d;
            border: 1px solid #555;
            border-radius: 5px;
            color: white;
        }
        .slider-value {
            text-align: center;
            font-size: 0.9em;
            color: #4fc3f7;
            margin-top: 5px;
        }
        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }
        button {
            flex: 1;
            padding: 15px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        #startBtn {
            background: #4caf50;
            color: white;
        }
        #stopBtn {
            background: #f44336;
            color: white;
        }
        #playBtn {
            background: #2196f3;
            color: white;
        }
        button:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        .status {
            text-align: center;
            margin-top: 20px;
            padding: 10px;
            border-radius: 5px;
            background: #333;
        }
        
        /* Style for ADSR controls */
        .adsr-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }
        
        .unison-controls {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }
        
        .effects-controls {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }
        
        /* ADSR envelope visualization */
        .adsr-visual {
            width: 100%;
            height: 100px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 5px;
            margin-top: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .adsr-path {
            fill: none;
            stroke: #4fc3f7;
            stroke-width: 3;
        }
        
        /* Color coding for effect values */
        #reverbValue, #delayValue {
            color: #9c27b0;
        }
        
        #lowCutValue, #highCutValue {
            color: #ff9800;
        }
        
        #volumeValue {
            color: #4caf50;
        }
        
        /* NEW: Checkbox styles */
        .filter-toggle-group {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
        }
        
        .filter-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            background: rgba(255, 152, 0, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .filter-toggle:hover {
            background: rgba(255, 152, 0, 0.2);
        }
        
        .filter-toggle.active {
            background: rgba(255, 152, 0, 0.3);
            box-shadow: 0 0 0 2px rgba(255, 152, 0, 0.5);
        }
        
        .filter-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .filter-toggle label {
            margin-bottom: 0;
            cursor: pointer;
            color: #ff9800;
        }
        
        .filter-slider-group {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
            margin-top: 10px;
        }
        
        .filter-sweep-info {
            text-align: center;
            font-size: 0.9em;
            color: #888;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="synth-container">
        <h1>Tone.js Synth with ADSR, Unison & Effects</h1>
        
        <!-- Waveform Selector -->
        <div class="control-group">
            <label for="waveform">Waveform Type:</label>
            <select id="waveform">
                <option value="sine">Sine Wave</option>
                <option value="square">Square Wave</option>
                <option value="sawtooth">Sawtooth Wave</option>
                <option value="triangle">Triangle Wave</option>
            </select>
        </div>
        
        <!-- Frequency Control -->
        <div class="control-group">
            <label for="frequency">Frequency (Hz): 
                <span id="frequencyValue">440</span>
            </label>
            <input type="range" id="frequency" min="50" max="2000" value="440" step="1">
        </div>
        
        <!-- Detune Control -->
        <div class="control-group">
            <label for="detune">Detune (cents): 
                <span id="detuneValue">0</span>
            </label>
            <input type="range" id="detune" min="-1200" max="1200" value="0" step="1">
        </div>
        
        <!-- UNISON CONTROLS -->
        <div class="unison-controls">
            <div class="control-group">
                <label for="unisonVoices">Unison Voices: 
                    <span id="unisonVoicesValue">4</span>
                </label>
                <input type="range" id="unisonVoices" min="1" max="8" value="4" step="1">
            </div>
            
            <div class="control-group">
                <label for="unisonDetune">Unison Detune (cents): 
                    <span id="unisonDetuneValue">10</span>
                </label>
                <input type="range" id="unisonDetune" min="0" max="100" value="10" step="1">
            </div>
            
            <div class="control-group">
                <label for="unisonSpread">Unison Spread: 
                    <span id="unisonSpreadValue">0.5</span>
                </label>
                <input type="range" id="unisonSpread" min="0" max="1" value="0.5" step="0.01">
            </div>
        </div>
        
        <!-- ADSR ENVELOPE CONTROLS -->
        <div class="adsr-controls">
            <div class="control-group">
                <label for="attack">Attack (sec): 
                    <span id="attackValue">0.1</span>
                </label>
                <input type="range" id="attack" min="0" max="2" value="0.1" step="0.01">
            </div>
            
            <div class="control-group">
                <label for="decay">Decay (sec): 
                    <span id="decayValue">0.2</span>
                </label>
                <input type="range" id="decay" min="0" max="2" value="0.2" step="0.01">
            </div>
            
            <div class="control-group">
                <label for="sustain">Sustain (0-1): 
                    <span id="sustainValue">0.7</span>
                </label>
                <input type="range" id="sustain" min="0" max="1" value="0.7" step="0.01">
            </div>
            
            <div class="control-group">
                <label for="release">Release (sec): 
                    <span id="releaseValue">0.5</span>
                </label>
                <input type="range" id="release" min="0" max="3" value="0.5" step="0.01">
            </div>
        </div>
        
        <!-- ADSR Visualization -->
        <div class="control-group">
            <label>ADSR Envelope:</label>
            <div class="adsr-visual">
                <svg width="100%" height="100%" id="adsrVisual">
                    <!-- ADSR path will be drawn here -->
                </svg>
            </div>
        </div>
        
        <!-- EFFECTS CONTROLS -->
        <div class="effects-controls">
            <div class="control-group">
                <label for="reverb">Reverb Mix: 
                    <span id="reverbValue">0.3</span>
                </label>
                <input type="range" id="reverb" min="0" max="1" value="0.3" step="0.01">
            </div>
            
            <div class="control-group">
                <label for="reverbSize">Reverb Size: 
                    <span id="reverbSizeValue">0.7</span>
                </label>
                <input type="range" id="reverbSize" min="0.1" max="1" value="0.7" step="0.01">
            </div>
            
            <div class="control-group">
                <label for="delay">Delay Mix: 
                    <span id="delayValue">0.2</span>
                </label>
                <input type="range" id="delay" min="0" max="1" value="0.2" step="0.01">
            </div>
            
            <div class="control-group">
                <label for="delayTime">Delay Time: 
                    <span id="delayTimeValue">0.25</span>
                </label>
                <input type="range" id="delayTime" min="0.1" max="1" value="0.25" step="0.01">
            </div>
            
            <div class="control-group">
                <label for="delayFeedback">Delay Feedback: 
                    <span id="delayFeedbackValue">0.3</span>
                </label>
                <input type="range" id="delayFeedback" min="0" max="0.95" value="0.3" step="0.01">
            </div>
        </div>
        
        <!-- NEW FILTER CONTROLS WITH CHECKBOXES -->
        <div class="control-group">
            <label>Filter Controls:</label>
            
            <!-- Filter Toggle Checkboxes -->
            <div class="filter-toggle-group">
                <div class="filter-toggle" id="lowCutToggle">
                    <input type="checkbox" id="lowCutActive">
                    <label for="lowCutActive">Low Cut Filter</label>
                </div>
                
                <div class="filter-toggle" id="highCutToggle">
                    <input type="checkbox" id="highCutActive">
                    <label for="highCutActive">High Cut Filter</label>
                </div>
            </div>
            
            <!-- Active Filter Slider -->
            <div class="filter-slider-group" id="activeFilterGroup" style="display: none;">
                <div id="lowCutSliderGroup" style="display: none;">
                    <label for="filterFrequency">Low Cut Frequency (Hz): 
                        <span id="filterFrequencyValue">20</span>
                    </label>
                    <input type="range" id="filterFrequency" min="20" max="20000" value="20" step="1">
                    <div class="filter-sweep-info">Sweeps from 20 Hz to 20,000 Hz</div>
                </div>
                
                <div id="highCutSliderGroup" style="display: none;">
                    <label for="filterFrequency">High Cut Frequency (Hz): 
                        <span id="filterFrequencyValue2">20000</span>
                    </label>
                    <input type="range" id="filterFrequency2" min="20" max="20000" value="20000" step="1">
                    <div class="filter-sweep-info">Sweeps from 20,000 Hz to 20 Hz</div>
                </div>
            </div>
        </div>
        
        <!-- VOLUME CONTROL -->
        <div class="control-group">
            <label for="volume">Volume (dB): 
                <span id="volumeValue">0</span>
            </label>
            <input type="range" id="volume" min="-60" max="0" value="0" step="1">
        </div>
        
        <!-- Buttons -->
        <div class="button-group">
            <button id="startBtn">Start Audio</button>
            <button id="stopBtn" disabled>Stop Audio</button>
            <button id="playBtn" disabled>Play Note</button>
        </div>
        
        <!-- Status Display -->
        <div class="status" id="status">Click "Start Audio" to begin</div>
    </div>

    <script>
        // Initialize variables
        let synth = null;
        let lowCutFilter = null;
        let highCutFilter = null;
        let volumeNode = null;
        let reverbNode = null;
        let delayNode = null;
        let dryWetMixer = null;
        let isPlaying = false;
        let audioStarted = false;
        let oscillators = [];
        let activeFilterType = null; // 'lowcut' or 'highcut'
        
        // DOM Elements
        const waveformSelect = document.getElementById('waveform');
        const frequencySlider = document.getElementById('frequency');
        const frequencyValue = document.getElementById('frequencyValue');
        const detuneSlider = document.getElementById('detune');
        const detuneValue = document.getElementById('detuneValue');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const playBtn = document.getElementById('playBtn');
        const statusDiv = document.getElementById('status');
        const adsrVisual = document.getElementById('adsrVisual');
        
        // NEW: Filter Toggle Elements
        const lowCutCheckbox = document.getElementById('lowCutActive');
        const highCutCheckbox = document.getElementById('highCutActive');
        const lowCutToggle = document.getElementById('lowCutToggle');
        const highCutToggle = document.getElementById('highCutToggle');
        const activeFilterGroup = document.getElementById('activeFilterGroup');
        const lowCutSliderGroup = document.getElementById('lowCutSliderGroup');
        const highCutSliderGroup = document.getElementById('highCutSliderGroup');
        
        // NEW: Combined Filter Slider
        const filterFrequencySlider = document.getElementById('filterFrequency');
        const filterFrequencyValue = document.getElementById('filterFrequencyValue');
        const filterFrequencySlider2 = document.getElementById('filterFrequency2');
        const filterFrequencyValue2 = document.getElementById('filterFrequencyValue2');
        
        // Volume control
        const volumeSlider = document.getElementById('volume');
        const volumeValue = document.getElementById('volumeValue');
        
        // ADSR Controls
        const attackSlider = document.getElementById('attack');
        const attackValue = document.getElementById('attackValue');
        const decaySlider = document.getElementById('decay');
        const decayValue = document.getElementById('decayValue');
        const sustainSlider = document.getElementById('sustain');
        const sustainValue = document.getElementById('sustainValue');
        const releaseSlider = document.getElementById('release');
        const releaseValue = document.getElementById('releaseValue');
        
        // UNISON Controls
        const unisonVoicesSlider = document.getElementById('unisonVoices');
        const unisonVoicesValue = document.getElementById('unisonVoicesValue');
        const unisonDetuneSlider = document.getElementById('unisonDetune');
        const unisonDetuneValue = document.getElementById('unisonDetuneValue');
        const unisonSpreadSlider = document.getElementById('unisonSpread');
        const unisonSpreadValue = document.getElementById('unisonSpreadValue');
        
        // EFFECTS Controls
        const reverbSlider = document.getElementById('reverb');
        const reverbValue = document.getElementById('reverbValue');
        const reverbSizeSlider = document.getElementById('reverbSize');
        const reverbSizeValue = document.getElementById('reverbSizeValue');
        const delaySlider = document.getElementById('delay');
        const delayValue = document.getElementById('delayValue');
        const delayTimeSlider = document.getElementById('delayTime');
        const delayTimeValue = document.getElementById('delayTimeValue');
        const delayFeedbackSlider = document.getElementById('delayFeedback');
        const delayFeedbackValue = document.getElementById('delayFeedbackValue');
        
        // Update display values for sliders
        frequencySlider.addEventListener('input', () => {
            frequencyValue.textContent = frequencySlider.value;
            updateADSRVisualization();
        });
        
        detuneSlider.addEventListener('input', () => {
            detuneValue.textContent = detuneSlider.value;
        });
        
        // Volume listener
        volumeSlider.addEventListener('input', () => {
            volumeValue.textContent = volumeSlider.value;
            if (volumeNode) {
                volumeNode.volume.value = parseFloat(volumeSlider.value);
            }
        });
        
        // Waveform change handler
        waveformSelect.addEventListener('change', () => {
            updateADSRVisualization();
        });
        
        // ADSR Slider Listeners
        attackSlider.addEventListener('input', () => {
            attackValue.textContent = attackSlider.value;
            updateADSRVisualization();
        });
        
        decaySlider.addEventListener('input', () => {
            decayValue.textContent = decaySlider.value;
            updateADSRVisualization();
        });
        
        sustainSlider.addEventListener('input', () => {
            sustainValue.textContent = sustainSlider.value;
            updateADSRVisualization();
        });
        
        releaseSlider.addEventListener('input', () => {
            releaseValue.textContent = releaseSlider.value;
            updateADSRVisualization();
        });
        
        // UNISON Slider Listeners
        unisonVoicesSlider.addEventListener('input', () => {
            unisonVoicesValue.textContent = unisonVoicesSlider.value;
        });
        
        unisonDetuneSlider.addEventListener('input', () => {
            unisonDetuneValue.textContent = unisonDetuneSlider.value;
        });
        
        unisonSpreadSlider.addEventListener('input', () => {
            unisonSpreadValue.textContent = unisonSpreadSlider.value;
        });
        
        // EFFECTS Slider Listeners
        reverbSlider.addEventListener('input', () => {
            reverbValue.textContent = reverbSlider.value;
            if (reverbNode) {
                reverbNode.wet.value = parseFloat(reverbSlider.value);
            }
        });
        
        reverbSizeSlider.addEventListener('input', () => {
            reverbSizeValue.textContent = reverbSizeSlider.value;
            if (reverbNode) {
                reverbNode.decay = parseFloat(reverbSizeSlider.value) * 10;
            }
        });
        
        delaySlider.addEventListener('input', () => {
            delayValue.textContent = delaySlider.value;
            if (delayNode) {
                delayNode.wet.value = parseFloat(delaySlider.value);
            }
        });
        
        delayTimeSlider.addEventListener('input', () => {
            delayTimeValue.textContent = delayTimeSlider.value;
            if (delayNode) {
                delayNode.delayTime.value = parseFloat(delayTimeSlider.value);
            }
        });
        
        delayFeedbackSlider.addEventListener('input', () => {
            delayFeedbackValue.textContent = delayFeedbackSlider.value;
            if (delayNode) {
                delayNode.feedback.value = parseFloat(delayFeedbackSlider.value);
            }
        });
        
        // NEW: Filter Toggle Listeners
        lowCutCheckbox.addEventListener('change', () => {
            if (lowCutCheckbox.checked) {
                // Uncheck high cut
                highCutCheckbox.checked = false;
                highCutToggle.classList.remove('active');
                
                // Activate low cut
                activeFilterType = 'lowcut';
                lowCutToggle.classList.add('active');
                
                // Show low cut slider
                activeFilterGroup.style.display = 'block';
                lowCutSliderGroup.style.display = 'block';
                highCutSliderGroup.style.display = 'none';
                
                // Update filter
                updateActiveFilter();
            } else {
                lowCutToggle.classList.remove('active');
                if (!highCutCheckbox.checked) {
                    activeFilterGroup.style.display = 'none';
                    activeFilterType = null;
                }
            }
            updateFilterConnections();
        });
        
        highCutCheckbox.addEventListener('change', () => {
            if (highCutCheckbox.checked) {
                // Uncheck low cut
                lowCutCheckbox.checked = false;
                lowCutToggle.classList.remove('active');
                
                // Activate high cut
                activeFilterType = 'highcut';
                highCutToggle.classList.add('active');
                
                // Show high cut slider
                activeFilterGroup.style.display = 'block';
                highCutSliderGroup.style.display = 'block';
                lowCutSliderGroup.style.display = 'none';
                
                // Update filter
                updateActiveFilter();
            } else {
                highCutToggle.classList.remove('active');
                if (!lowCutCheckbox.checked) {
                    activeFilterGroup.style.display = 'none';
                    activeFilterType = null;
                }
            }
            updateFilterConnections();
        });
        
        // NEW: Filter Frequency Slider Listeners
        filterFrequencySlider.addEventListener('input', () => {
            const value = filterFrequencySlider.value;
            filterFrequencyValue.textContent = value;
            
            if (lowCutFilter && activeFilterType === 'lowcut') {
                lowCutFilter.frequency.value = parseFloat(value);
            }
        });
        
        filterFrequencySlider2.addEventListener('input', () => {
            const value = filterFrequencySlider2.value;
            filterFrequencyValue2.textContent = value;
            
            if (highCutFilter && activeFilterType === 'highcut') {
                highCutFilter.frequency.value = parseFloat(value);
            }
        });
        
        // Function to update active filter based on slider position
        function updateActiveFilter() {
            if (activeFilterType === 'lowcut' && lowCutFilter) {
                const value = parseFloat(filterFrequencySlider.value);
                lowCutFilter.frequency.value = value;
            } else if (activeFilterType === 'highcut' && highCutFilter) {
                const value = parseFloat(filterFrequencySlider2.value);
                highCutFilter.frequency.value = value;
            }
        }
        
        // Function to update filter connections in audio chain
        function updateFilterConnections() {
            if (!audioStarted || !dryWetMixer) return;
            
            // Disconnect all filters first
            if (lowCutFilter) {
                lowCutFilter.disconnect();
            }
            if (highCutFilter) {
                highCutFilter.disconnect();
            }
            
            // Reconnect based on active filter
            if (activeFilterType === 'lowcut' && lowCutFilter) {
                // Connect: source → lowCutFilter → volume
                lowCutFilter.connect(volumeNode);
            } else if (activeFilterType === 'highcut' && highCutFilter) {
                // Connect: source → highCutFilter → volume
                highCutFilter.connect(volumeNode);
            } else {
                // No filter active, connect directly to volume
                // This will be handled in the playNote function
            }
        }
        
        // Function to create multiple oscillators for unison
        function createUnisonOscillators(freq, type, detune) {
            oscillators = [];
            const voices = parseInt(unisonVoicesSlider.value);
            const spread = parseFloat(unisonSpreadSlider.value);
            const unisonDetune = parseFloat(unisonDetuneSlider.value);
            
            // Create master gain node for all oscillators
            const masterGain = new Tone.Gain(1);
            
            for (let i = 0; i < voices; i++) {
                // Calculate voice position (0 to 1)
                const voicePosition = voices === 1 ? 0.5 : i / (voices - 1);
                
                // Calculate detune (-1 to 1 range)
                const positionNormalized = (voicePosition * 2) - 1;
                const voiceDetune = detune + (positionNormalized * unisonDetune * spread);
                
                // Calculate phase
                const phase = (i / Math.max(voices, 1)) * 360;
                
                // Create oscillator
                const osc = new Tone.Oscillator({
                    frequency: freq,
                    type: type,
                    detune: voiceDetune,
                    phase: phase
                });
                
                // Create individual gain for each oscillator
                const voiceGain = new Tone.Gain(1 / Math.sqrt(Math.max(voices, 1)));
                
                // Connect: Oscillator → Voice Gain → Master Gain
                osc.connect(voiceGain);
                voiceGain.connect(masterGain);
                
                oscillators.push({
                    oscillator: osc,
                    gain: voiceGain
                });
            }
            
            return masterGain;
        }
        
        // Function to update ADSR visualization
        function updateADSRVisualization() {
            const width = adsrVisual.clientWidth;
            const height = adsrVisual.clientHeight;
            
            // Clear previous visualization
            adsrVisual.innerHTML = '';
            
            // Calculate time values
            const attack = parseFloat(attackSlider.value);
            const decay = parseFloat(decaySlider.value);
            const sustain = parseFloat(sustainSlider.value);
            const release = parseFloat(releaseSlider.value);
            
            // Total width for A+D+S
            const totalADS = attack + decay + 0.5;
            
            // Scale factors
            const xScale = width / (totalADS + release + 0.5);
            const yScale = height * 0.9;
            
            // Create path
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            
            // Build path points
            let pathData = `M 0 ${height} `;
            const attackX = attack * xScale;
            pathData += `L ${attackX} ${height - yScale} `;
            
            const decayX = attackX + (decay * xScale);
            const sustainY = height - (sustain * yScale);
            pathData += `L ${decayX} ${sustainY} `;
            
            const sustainX = decayX + (0.5 * xScale);
            pathData += `L ${sustainX} ${sustainY} `;
            
            const releaseX = sustainX + (release * xScale);
            pathData += `L ${releaseX} ${height} `;
            
            pathData += `L ${width} ${height}`;
            
            path.setAttribute("d", pathData);
            path.setAttribute("class", "adsr-path");
            
            adsrVisual.appendChild(path);
            
            // Add labels
            addLabel(adsrVisual, "A", attackX / 2, height - 10);
            addLabel(adsrVisual, "D", attackX + (decayX - attackX) / 2, height - 10);
            addLabel(adsrVisual, "S", decayX + (sustainX - decayX) / 2, height - 10);
            addLabel(adsrVisual, "R", sustainX + (releaseX - sustainX) / 2, height - 10);
        }
        
        function addLabel(svg, text, x, y) {
            const textEl = document.createElementNS("http://www.w3.org/2000/svg", "text");
            textEl.setAttribute("x", x);
            textEl.setAttribute("y", y);
            textEl.setAttribute("text-anchor", "middle");
            textEl.setAttribute("fill", "#888");
            textEl.setAttribute("font-size", "12");
            textEl.textContent = text;
            svg.appendChild(textEl);
        }
        
        // Start Audio Context
        startBtn.addEventListener('click', async () => {
            try {
                // Start Tone.js audio context
                await Tone.start();
                
                // Create audio nodes
                createAudioNodes();
                
                // Initialize ADSR visualization
                updateADSRVisualization();
                
                audioStarted = true;
                statusDiv.textContent = "Audio started! Click 'Play Note' to hear sound";
                statusDiv.style.background = "#2e7d32";
                
                // Enable/disable buttons
                startBtn.disabled = true;
                stopBtn.disabled = false;
                playBtn.disabled = false;
                
                console.log("Audio context started successfully");
            } catch (error) {
                statusDiv.textContent = "Error starting audio: " + error.message;
                statusDiv.style.background = "#c62828";
                console.error("Error starting audio:", error);
            }
        });
        
        // Stop Audio
        stopBtn.addEventListener('click', () => {
            if (isPlaying) {
                stopNote();
            }
            
            audioStarted = false;
            statusDiv.textContent = "Audio stopped. Click 'Start Audio' to begin again";
            statusDiv.style.background = "#333";
            
            // Enable/disable buttons
            startBtn.disabled = false;
            stopBtn.disabled = true;
            playBtn.disabled = true;
            playBtn.textContent = "Play Note";
            
            console.log("Audio stopped");
        });
        
        // Play/Stop Note
        playBtn.addEventListener('click', async () => {
            if (!audioStarted) {
                statusDiv.textContent = "Please start audio first!";
                return;
            }
            
            if (!isPlaying) {
                await playNote();
            } else {
                stopNote();
            }
        });
        
        // Function to play note with unison and ADSR
        async function playNote() {
            try {
                // Stop any existing sound
                if (oscillators.length > 0) {
                    oscillators.forEach(({ oscillator }) => oscillator.stop());
                    oscillators = [];
                }
                
                // Create ADSR envelope
                const adsrEnvelope = new Tone.AmplitudeEnvelope({
                    attack: parseFloat(attackSlider.value),
                    decay: parseFloat(decaySlider.value),
                    sustain: parseFloat(sustainSlider.value),
                    release: parseFloat(releaseSlider.value)
                });
                
                // Create unison oscillators
                const masterGain = createUnisonOscillators(
                    parseFloat(frequencySlider.value),
                    waveformSelect.value,
                    parseFloat(detuneSlider.value)
                );
                
                // Connect based on active filter
                masterGain.connect(adsrEnvelope);
                
                if (activeFilterType === 'lowcut' && lowCutFilter) {
                    // Low cut only
                    adsrEnvelope.chain(lowCutFilter, dryWetMixer);
                } else if (activeFilterType === 'highcut' && highCutFilter) {
                    // High cut only
                    adsrEnvelope.chain(highCutFilter, dryWetMixer);
                } else {
                    // No filter
                    adsrEnvelope.connect(dryWetMixer);
                }
                
                // Start all oscillators
                oscillators.forEach(({ oscillator }) => {
                    oscillator.start();
                });
                
                // Trigger ADSR envelope
                adsrEnvelope.triggerAttack();
                
                isPlaying = true;
                playBtn.textContent = "Stop Note";
                statusDiv.textContent = `Playing ${oscillators.length}-voice unison`;
                if (activeFilterType) {
                    statusDiv.textContent += ` with ${activeFilterType} filter`;
                }
                statusDiv.style.background = "#1565c0";
                
                console.log(`Started ${oscillators.length}-voice unison with ${activeFilterType || 'no'} filter`);
                
            } catch (error) {
                console.error("Error playing note:", error);
                statusDiv.textContent = "Error playing note";
                statusDiv.style.background = "#c62828";
            }
        }
        
        // Function to stop note with ADSR release
        function stopNote() {
            if (oscillators.length > 0 && isPlaying) {
                // Find the envelope in the chain
                const adsrEnvelope = dryWetMixer.input;
                
                if (adsrEnvelope && adsrEnvelope.triggerRelease) {
                    adsrEnvelope.triggerRelease();
                    
                    // Schedule oscillator stop after release completes
                    setTimeout(() => {
                        oscillators.forEach(({ oscillator }) => {
                            oscillator.stop();
                        });
                        oscillators = [];
                        isPlaying = false;
                        playBtn.textContent = "Play Note";
                        statusDiv.textContent = "Note stopped";
                        statusDiv.style.background = "#2e7d32";
                    }, parseFloat(releaseSlider.value) * 1000 + 100);
                } else {
                    // Fallback: immediate stop
                    oscillators.forEach(({ oscillator }) => {
                        oscillator.stop();
                    });
                    oscillators = [];
                    isPlaying = false;
                    playBtn.textContent = "Play Note";
                    statusDiv.textContent = "Note stopped";
                    statusDiv.style.background = "#2e7d32";
                }
            }
        }
        
        // Function to create audio nodes (filters, effects, and volume)
        function createAudioNodes() {
            // Create filters (but don't connect them yet)
            lowCutFilter = new Tone.Filter({
                frequency: parseFloat(filterFrequencySlider.value),
                type: "highpass"
            });
            
            highCutFilter = new Tone.Filter({
                frequency: parseFloat(filterFrequencySlider2.value),
                type: "lowpass"
            });
            
            // Create volume control
            volumeNode = new Tone.Volume(parseFloat(volumeSlider.value));
            
            // Create reverb effect
            reverbNode = new Tone.Reverb({
                decay: parseFloat(reverbSizeSlider.value) * 10,
                preDelay: 0.01
            });
            
            reverbNode.wet.value = parseFloat(reverbSlider.value);
            
            // Create delay effect
            delayNode = new Tone.FeedbackDelay({
                delayTime: parseFloat(delayTimeSlider.value),
                feedback: parseFloat(delayFeedbackSlider.value),
                wet: parseFloat(delaySlider.value)
            });
            
            // Create dry/wet mixer for effects chain
            dryWetMixer = new Tone.Gain(1);
            
            // Connect effects in parallel
            dryWetMixer.connect(volumeNode);
            
            const reverbSend = new Tone.Gain(0.5);
            const delaySend = new Tone.Gain(0.5);
            
            dryWetMixer.connect(reverbSend);
            dryWetMixer.connect(delaySend);
            
            reverbSend.connect(reverbNode);
            delaySend.connect(delayNode);
            
            reverbNode.connect(volumeNode);
            delayNode.connect(volumeNode);
            
            // Finally connect to destination
            volumeNode.connect(Tone.Destination);
            
            console.log("Audio nodes created with filters, effects, and volume");
        }
        
        // Log initialization
        console.log("Synth with ADSR, Unison & Effects initialized");
    </script>
</body>
</html>
